name: Weekly Market Pressure Scan

on:
  schedule:
    - cron: "5 21 * * 5"  # 4:05pm ET (Fridays at 21:05 UTC during EST)
  workflow_dispatch:
    inputs:
      week_end:
        description: "Week ending date (YYYY-MM-DD). Leave blank to auto-compute."
        required: false
        default: ""

concurrency:
  group: market-pressure-scan-${{ github.event_name }}-${{ github.event.inputs.week_end || 'auto' }}
  cancel-in-progress: ${{ github.event_name == 'schedule' }}

jobs:
  run-pipeline:
    runs-on: ubuntu-latest
    outputs:
      week_end: ${{ steps.week_end.outputs.week_end }}
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Guard - only proceed at 4:05pm ET (scheduled only)
        run: |
          python - <<'PY'
          import datetime as dt
          from zoneinfo import ZoneInfo
          import os

          event = os.environ.get("GITHUB_EVENT_NAME", "")
          
          # Only enforce time guard for scheduled runs
          if event == "schedule":
              now = dt.datetime.now(ZoneInfo("America/New_York"))
              if not (now.weekday() == 4 and now.hour == 16 and now.minute == 5):
                  print(f"Not 4:05pm ET Friday (now={now}). Exiting successfully.")
                  raise SystemExit(0)
              print(f"Guard passed for scheduled run: now={now}")
          else:
              print(f"Manual run (event={event}), bypassing time guard. Proceeding.")
          PY
        env:
          GITHUB_EVENT_NAME: ${{ github.event_name }}

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Verify required secrets present
        env:
          FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          test -n "${FINNHUB_API_KEY}" || (echo "âŒ FINNHUB_API_KEY secret missing" && exit 1)
          test -n "${OPENAI_API_KEY}" || (echo "âŒ OPENAI_API_KEY secret missing" && exit 1)
          echo "âœ“ Required secrets present"

      - name: Universe sanity check
        run: |
          echo "UNIVERSE PATH: sp500_universe.csv"
          wc -l sp500_universe.csv
          echo "---"
          head -5 sp500_universe.csv
          echo "..."
          tail -3 sp500_universe.csv

      - name: Determine week_end
        id: week_end
        shell: bash
        run: |
          set -euo pipefail
          WEEK_END="${{ github.event.inputs.week_end }}"
          
          if [ -z "$WEEK_END" ]; then
            # Auto-compute: today if Friday else last Friday (ET)
            WEEK_END=$(python - <<'PY'
          import datetime as dt
          from zoneinfo import ZoneInfo
          today = dt.datetime.now(ZoneInfo("America/New_York")).date()
          if today.weekday() == 4:
              week_end = today
          else:
              days_since_fri = (today.weekday() - 4) % 7
              week_end = today - dt.timedelta(days=days_since_fri)
          print(week_end.isoformat())
          PY
          )
          fi
          
          # Validate week_end format (strict ISO date check)
          python - <<PY
          import sys, datetime as dt
          s = "${WEEK_END}"
          try:
              dt.date.fromisoformat(s)
          except Exception as e:
              print(f"Invalid week_end: {s!r} (expected YYYY-MM-DD)", file=sys.stderr)
              sys.exit(2)
          PY
          
          # Write to workspace root for Python scripts
          echo "$WEEK_END" > "$GITHUB_WORKSPACE/week_end.txt"
          
          # Set outputs for workflow steps and job outputs
          echo "week_end=$WEEK_END" >> "$GITHUB_OUTPUT"
          echo "âœ“ Week ending: $WEEK_END"

      - name: Run weekly pipeline
        env:
          FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          WEEK_END="${{ steps.week_end.outputs.week_end }}"
          python -m src.run_weekly_pipeline --week_end "$WEEK_END" --max_clusters_per_symbol 1 --skip_backtest
          python -m src.update_weekly_pnl --week_end "$WEEK_END"
          python -m src.scoreboard
          python -m src.trader_sheet --week_end "$WEEK_END"
          python -m src.log_week_decision --week_end "$WEEK_END"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: trader-sheet-and-report
          path: |
            data/derived/trader_sheets/**
            data/derived/reports/**
            data/derived/baskets/**
            data/live/scoreboard.csv

      - name: Create notification issue
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const week_end = '${{ steps.week_end.outputs.week_end }}';
            const status = '${{ job.status }}';
            const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            // Read scoreboard
            let scoreboardSnippet = 'Scoreboard not available';
            try {
              const scoreboard = fs.readFileSync('data/live/scoreboard.csv', 'utf8');
              const lines = scoreboard.split('\n').slice(0, 10);
              scoreboardSnippet = '```\n' + lines.join('\n') + '\n```';
            } catch (e) {
              scoreboardSnippet = 'Could not read scoreboard';
            }
            
            // Read basket for action + top symbols (canonical source)
            let actionDecision = 'UNKNOWN';
            let topSymbols = 'Not available';
            let basketSize = 0;
            let overlapPct = null;
            let turnoverPct = null;
            
            try {
              const basketPath = `data/derived/baskets/week_ending=${week_end}/basket.csv`;
              const basketCsv = fs.readFileSync(basketPath, 'utf8').trim();
              const rows = basketCsv.split('\n').filter(r => r.trim().length > 0);
              
              // Parse header to find column indices
              const header = rows[0].split(',');
              const actionIdx = header.indexOf('action');
              const reasonIdx = header.indexOf('reason');
              const symbolIdx = header.indexOf('symbol');
              const upsIdx = header.indexOf('UPS_adj');
              const convictionIdx = header.indexOf('conviction');
              
              // Parse first data row to read action
              const firstRow = rows[1]?.split(',') || [];
              const action = actionIdx >= 0 ? (firstRow[actionIdx] || '').trim() : '';
              
              if (action === 'SKIP') {
                actionDecision = 'â¸ï¸ SKIP';
                const reason = reasonIdx >= 0 ? (firstRow[reasonIdx] || '').trim() : 'Low-information week';
                topSymbols = reason || 'Low-information week';
                basketSize = 0;
              } else {
                actionDecision = 'ðŸ“ˆ TRADE';
                
                // Count symbol rows (exclude header)
                const symbolRows = rows.slice(1).filter(r => r.trim());
                basketSize = symbolRows.length;
                
                // Top 5 from file order (already ranked by UPS)
                const top5 = symbolRows.slice(0, 5).map(r => {
                  const cols = r.split(',');
                  const ticker = symbolIdx >= 0 ? (cols[symbolIdx] || '?').trim() : '?';
                  const ups = upsIdx >= 0 ? (cols[upsIdx] || '?').trim() : '?';
                  const conviction = convictionIdx >= 0 ? (cols[convictionIdx] || '?').trim() : '?';
                  return `${ticker} (UPS: ${ups}, ${conviction})`;
                });
                
                topSymbols = top5.join('\n');
              }
            } catch (e) {
              topSymbols = `Could not read basket: ${e.message}`;
            }
            
            // Read weeks_log for turnover metrics
            try {
              const weeksLog = fs.readFileSync('data/live/weeks_log.csv', 'utf8');
              const lines = weeksLog.split('\n');
              const currentWeekLine = lines.find(line => line.includes(week_end));
              
              if (currentWeekLine) {
                const cols = currentWeekLine.split(',');
                // Assuming CSV columns: week_ending_date,action,basket_size,overlap_pct,turnover_pct,...
                basketSize = parseInt(cols[2]) || basketSize;
                overlapPct = parseFloat(cols[3]);
                turnoverPct = parseFloat(cols[4]);
              }
            } catch (e) {
              // Weeks log might not exist yet or metric not available
            }
            
            const body = `@fju7 â€” Your weekly market pressure scan is ready!
            
            ## ðŸ“Š Weekly Market Pressure Scan Complete
            
            **Week Ending:** ${week_end}
            **Status:** ${status === 'success' ? 'âœ… Success' : 'âŒ Failed'}
            **Basket Size:** ${basketSize}${overlapPct !== null ? `\n**Overlap:** ${overlapPct.toFixed(1)}% | **Turnover:** ${turnoverPct.toFixed(1)}%` : ''}
            
            ### ${actionDecision}
            
            **Top 5 UPS Signals:**
            \`\`\`
            ${topSymbols}
            \`\`\`
            
            ### Quick Stats
            ${scoreboardSnippet}
            
            ### ðŸ”— Links
            - **[ðŸ“¥ View Run & Download Artifacts](${runUrl})**
            - Artifacts include: Trader Sheet, Weekly Report, Basket, Scoreboard
            
            ---
            *This issue auto-closes in 7 days*`;
             of res.data) {
                const created = new Date(issue.created_at);
                const daysOld = (now - created) / (1000 * 60 * 60 * 24);
            
                if (daysOl
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ“ˆ Weekly Scan: ${week_end}`,
              body: body,
              labels: ['weekly-scan', 'automated']
            });
            
            // Ensure we have a numeric issue number (not node_id)
            const issueNumber = parseInt(issue.data.number, 10);
            if (!issueNumber || isNaN(issueNumber)) {
              throw new Error(`Invalid issue number: ${issue.data.number}`);
            }
            
            // Schedule auto-close in 7 days
            const closeDate = new Date();
            closeDate.setDate(closeDate.getDate() + 7);
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `ðŸ¤– This issue will auto-close on ${closeDate.toISOString().split('T')[0]}`
            });
            
            // Return issue number for potential auto-close step
            return issueNumber;

      - name: Auto-close old weekly-scan issues
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            
            const cutoffDays = 7;
            const now = new Date();
            let closed = 0;
            let page = 1;
            
            while (true) {
              const res = await github.rest.issues.listForRepo({
                owner,
                repo,
                labels: 'weekly-scan',
                state: 'open',
                sort: 'created',
                direction: 'asc',   // oldest first so we can break early
                per_page: 100,
                page
              });
            
              if (!res.data || res.data.length === 0) break;
            
              for (const issue of res.data) {
                const created = new Date(issue.created_at);
                const daysOld = (now - created) / (1000 * 60 * 60 * 24);
            
                // since we're oldest->newest, once we hit a "too new" issue, we can stop entirely
                if (daysOld < cutoffDays) {
                  console.log(`Hit issues newer than cutoff (${daysOld.toFixed(2)}d < ${cutoffDays}d). Stopping.`);
                  console.log(`Closed ${closed} old weekly-scan issue(s).`);
                  return;
                }
            
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issue.number,
                  body: `ðŸ¤– Auto-closing: this weekly scan issue is ${daysOld.toFixed(1)} days old (>= ${cutoffDays}).`
                });
            
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
            
                closed += 1;
              }
            
              page += 1;
            }
            
            console.log(`Closed ${closed} old weekly-scan issue(s).`);
